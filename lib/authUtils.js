import AsyncStorage from '@react-native-async-storage/async-storage';
import { CommonActions } from '@react-navigation/native';
import * as Crypto from 'expo-crypto';
import {
  formatIncompletePhoneNumber,
  parsePhoneNumberFromString,
} from 'libphonenumber-js';
import { env, HC_SECRET } from '../environment';
import {
  createPushToken,
  getCustomerById,
  updateCustomer,
} from './airtable/request';
import { clearUserLog, logErrorToSentry } from './logUtils';

// Fields

export const inputFields = {
  NAME: 0,
  PHONENUM: 1,
  CODE: 2,
};

// Notifications option names

export const notificationTypes = {
  SMS: 'SMS',
  PUSH: 'Push',
};

// Password encryption -- DEPRECATED as of 8/26/20
export const encryptPassword = async (customerId, password) => {
  try {
    // Because Airtable record IDs are unique, generated by, and stored in Airtable
    // they are a good choice for a salt
    const salt = customerId;
    const hashingAlgorithm = Crypto.CryptoDigestAlgorithm.SHA256;
    const plaintext = password;
    const salted = plaintext.concat(salt);
    const hash = await Crypto.digestStringAsync(hashingAlgorithm, salted);
    return hash;
  } catch (err) {
    console.error(err);
    logErrorToSentry({
      action: 'encryptPassword',
      error: err,
    });
  }
  return null;
};

// newToken is the value generated by Expo; a string
// updateCustomerPushTokens is called after customer is looked up
export async function updateCustomerPushTokens(customer, newToken) {
  // If tokens are not being registered, do nothing
  if (!newToken) {
    return;
  }
  // If Notifications errored while registering token, may not have registered a pushToken initially
  // Else, we need to check if this device has already been registered to the user
  const isNew =
    'pushTokenIds' in customer &&
    'tokenNames' in customer &&
    !customer.tokenNames.includes(newToken);
  if (isNew) {
    const tokenId = await createPushToken(newToken);
    await updateCustomer(customer.id, {
      pushTokenIds: [...customer.pushTokenIds, tokenId],
    });
  }
}

// Formats full phone numbers by (...) ...-.... or returns null if the number is not 10 digits
export function formatPhoneNumber(phoneNumber) {
  const parsedPhoneNumber = parsePhoneNumberFromString(`+1${phoneNumber}`);
  if (parsedPhoneNumber && parsedPhoneNumber.isPossible()) {
    return parsedPhoneNumber.formatNational();
  }
  return null;
}

// Automatically formats phone number input to (...) ...-.... as the user types
export function formatPhoneNumberInput(text) {
  let formatted = formatIncompletePhoneNumber(text, 'US');
  // Workaround for a bug that doesn't allow backspacing the closing parenthesis
  if (formatted.slice(-1) === ')') {
    formatted = formatted.slice(0, -1);
  }
  return formatted;
}

export async function sendTextMessage(customerId, message) {
  // Only send the message in production mode to save Twilio credits
  if (env !== 'dev') {
    try {
      const customer = await getCustomerById(customerId);
      const response = await fetch(
        'https://healthycorners-rewards-node.herokuapp.com/send_sms',
        {
          method: 'POST',
          headers: {
            Accept: 'application/json',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            key: HC_SECRET,
            to: '+1'.concat(customer.phoneNumber),
            message,
          }),
        }
      );
      return response.ok;
    } catch (err) {
      logErrorToSentry({
        action: 'sendTextMessage',
        error: err,
      });
      return null;
    }
  }
  return null;
}

export async function completeLogout(navigation, toSignIn = false) {
  const delay = (duration) =>
    new Promise((resolve) => setTimeout(resolve, duration));
  await delay(1000);
  clearUserLog();
  await AsyncStorage.removeItem('customerId');
  const routes = [
    {
      name: 'Auth',
      params: {
        screen: 'Onboarding',
      },
    },
  ];
  if (toSignIn) {
    routes.push({
      name: 'Auth',
      params: {
        screen: 'PhoneNumber',
      },
    });
  }
  navigation.dispatch(
    CommonActions.reset({
      routes,
    })
  );
}

const ASYNC_CUSTOMER_ID = 'customerId';
/**
 * Set customer login
 * @param {Object} customerIdObj - customer id object to set
 * @returns void
 */
export const setAsyncCustomerAuth = async (customerIdObj) => {
  try {
    await AsyncStorage.setItem(
      ASYNC_CUSTOMER_ID,
      JSON.stringify(customerIdObj)
    );
  } catch (e) {
    // error reading value
  }
};

/**
 * Get customer auth
 * @returns {Object} customerIdObj - customer id object to set
 */
export const getAsyncCustomerAuth = async () => {
  try {
    const jsonValue = await AsyncStorage.getItem(ASYNC_CUSTOMER_ID);
    return jsonValue !== null ? JSON.parse(jsonValue) : null;
  } catch (e) {
    // error reading value
    return null;
  }
};
