import * as Crypto from 'expo-crypto';
import {
  formatIncompletePhoneNumber,
  parsePhoneNumberFromString,
} from 'libphonenumber-js';
import { createPushToken, updateCustomer } from './airtable/request';
import { logErrorToSentry } from './logUtils';
// Fields

export const inputFields = {
  NAME: 0,
  PHONENUM: 1,
  CODE: 2,
};

// Password encryption -- DEPRECATED as of 8/26/20
export const encryptPassword = async (customerId, password) => {
  try {
    // Because Airtable record IDs are unique, generated by, and stored in Airtable
    // they are a good choice for a salt
    const salt = customerId;
    const hashingAlgorithm = Crypto.CryptoDigestAlgorithm.SHA256;
    const plaintext = password;
    const salted = plaintext.concat(salt);
    const hash = await Crypto.digestStringAsync(hashingAlgorithm, salted);
    return hash;
  } catch (err) {
    console.error(err);
    logErrorToSentry({
      action: 'encryptPassword',
      error: err,
    });
  }
  return null;
};

// newToken is the value generated by Expo; a string
// updateCustomerPushTokens is called after customer is looked up
export async function updateCustomerPushTokens(customer, newToken) {
  // If tokens are not being registered, do nothing
  if (!newToken) {
    return;
  }
  // If Notifications errored while registering token, may not have registered a pushToken initially
  // Else, we need to check if this device has already been registered to the user
  const isNew =
    'pushTokenIds' in customer &&
    'tokenNames' in customer &&
    !customer.tokenNames.includes(newToken);
  if (isNew) {
    const tokenId = await createPushToken(newToken);
    await updateCustomer(customer.id, {
      pushTokenIds: [...customer.pushTokenIds, tokenId],
    });
  }
}

// Formats full phone numbers by (...) ...-.... or returns null if the number is not 10 digits
export function formatPhoneNumber(phoneNumber) {
  const parsedPhoneNumber = parsePhoneNumberFromString(`+1${phoneNumber}`);
  if (parsedPhoneNumber && parsedPhoneNumber.isPossible()) {
    return parsedPhoneNumber.formatNational();
  }
  return null;
}

// Automatically formats phone number input to (...) ...-.... as the user types
export function formatPhoneNumberInput(text) {
  let formatted = formatIncompletePhoneNumber(text, 'US');
  // Workaround for a bug that doesn't allow backspacing the closing parenthesis
  if (formatted.slice(-1) === ')') {
    formatted = formatted.slice(0, -1);
  }
  return formatted;
}
