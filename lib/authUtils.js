import validatejs from 'validate.js';
import Colors from '../assets/Colors';
import BASE from './common';

// Fields

export const signUpFields = { NAME: 0, PHONENUM: 1, PASSWORD: 2 };

export const fieldStateColors = {
  INACTIVE: Colors.secondaryText,
  BLURRED: Colors.activeText,
  FOCUSED: Colors.primaryGreen,
  ERROR: Colors.darkerOrange
};

// lookupCustomer searches for users based on their phone numbers
// in the form (XXX) XXX-XXXX and checks against a correct password
// If the user is found, we return a subset of fields in Airtable
// Otherwise, we return null & display an error on the login screen.
export const lookupCustomer = function async(phoneNumber, password) {
  return new Promise((resolve, reject) => {
    let customerInfo = {
      custId: null,
      pushTokens: null,
      tokenNames: null
    };

    BASE('Customers')
      .select({
        maxRecords: 1,
        filterByFormula: `AND({Phone Number} = '${phoneNumber}', {Password} = '${password}')`
      })
      .firstPage()
      .then(records => {
        if (records.length !== 0) {
          records.forEach(function id(record) {
            customerInfo.custId = record.getId();
            customerInfo.pushTokens = record.fields['Push Tokens'];
            customerInfo.tokenNames = record.fields.token_names;
          });
        } else {
          customerInfo = null;
        }
        // If no records exist, resolves with null object
        resolve(customerInfo);
      })
      .catch(err => reject(err));
  });
};

// updateCustomerPushTokens is called after lookupCustomer; and only if lookupCustomer returns non-null.
export const updateCustomerPushTokens = function async(customerInfo, currentToken) {
  // currentToken is the value generated by Expo; a string
  return new Promise((resolve, reject) => {
    const { custId, tokenNames } = customerInfo;
    let { pushTokens } = customerInfo;
    // Loop through and check if currentToken is new
    let isNew = true;
    let i;

    // In a rare case (or in development), may not have registered a pushToken initially
    if (tokenNames) {
      for (i = 0; i < tokenNames.length; i += 1) {
        if (tokenNames[i] === currentToken) {
          isNew = false;
          break;
        }
      }
    }
    if (isNew) {
      // If it is new, create a new push token & add to pushTokens (local var)
      createPushToken(currentToken)
        .then(tokenRecords => {
          if (tokenRecords) {
            let tokenId = null;
            // Get tokenId
            tokenRecords.forEach(function process(record) {
              tokenId = record.getId();
            });
            // In a rare case (or in development), may not have registered a pushToken initially
            if (pushTokens) {
              // Append new tokenId to the list, then propagate value to next function
              pushTokens.push(tokenId);
            } else {
              pushTokens = [tokenId];
            }
            return pushTokens;
          }
          console.log('Error creating token');
          return null;
        })
        .catch(err => reject(err))
        .then(updatedPushTokens => {
          if (updatedPushTokens) {
            // Update this customer's pushTokens array
            BASE('Customers')
              .update([
                {
                  id: custId,
                  fields: {
                    'Push Tokens': updatedPushTokens
                  }
                }
              ])
              .then(records => {
                // If update is successful, resolve with customer ID
                records.forEach(record => resolve(record.getId()));
              })
              .catch(err => reject(err));
          }
          // Otherwise, error creating token; do nothing
          // Return null for semantics, resolve is what passes value back from the promise
          return null;
        })
        .catch(err => reject(err));
    } else {
      resolve(custId);
    }
  });
};

export function formatPhoneNumber(phoneNumber) {
  const onlyNumeric = phoneNumber.replace('[^0-9]', '');
  const formatted = `(${onlyNumeric.slice(0, 3)}) ${onlyNumeric.slice(3, 6)}-${onlyNumeric.slice(6, 10)}`;
  return formatted;
}

// For future use, to match for better passwords
// TODO: @Johnathan Fix passwords check
const pattern = '((?=.*d)(?=.*[a-z])(?=.*[A-Z])(?=.*[W]).{6,20})';

// This is to create constraints for the validatejs library
const validation = {
  name: {
    presence: {
      message: '^Name cannot be blank.'
    }
  },
  phoneNumber: {
    // This verifies that it's not blank.
    presence: {
      message: '^Phone number cannot be blank.'
    },
    length: {
      is: 10,
      message: '^Must be a valid phone number'
    }
    // To check for only numbers in the future
    // format: {
    //   pattern: '/^d+$/',
    //   message: 'Phone number cannot contain non-numeric characters.'
    // }
  },

  password: {
    presence: {
      message: '^Password cannot be blank.'
    },
    length: {
      minimum: 8,
      maximum: 20,
      message: '^Must be 8-20 characters long'
    }
    // For future use for better password checking
    // format: {
    //   pattern: "[a-z0-9]+",
    //   flags: "i",
    //   message: "Must contain at least one digit, one lowercase number, and special chracter"
    // }
  }
};

// This is the validate function that utilizes validate.js
// to check a fieldname based on an inputted value.
export function validate(fieldName, value) {
  // Validate.js validates your values as an object
  // e.g. var form = {email: 'email@example.com'}
  // Line 8-9 creates an object based on the field name and field value
  const values = {};
  values[fieldName] = value;

  const constraints = {};
  constraints[fieldName] = validation[fieldName];
  // The values and validated against the constraints
  // the variable result hold the error messages of the field
  const result = validatejs(values, constraints);
  // If there is an error message, return it!
  if (result) {
    // Return only the field error message if there are multiple
    return result[fieldName][0];
  }
  // Otherwise, return null
  return null;
}
