import * as Crypto from 'expo-crypto';
import { createPushTokens, updateCustomers } from './airtable/request';
import { logErrorToSentry } from './logUtils';
// Fields

export const inputFields = {
  NAME: 0,
  PHONENUM: 1,
  PASSWORD: 2,
  NEWPASSWORD: 3,
  VERIFYPASSWORD: 4,
  CODE: 5,
};

// Encryption
export const encryptPassword = async (customerId, password) => {
  try {
    // Because Airtable record IDs are unique, generated by, and stored in Airtable
    // they are a good choice for a salt
    const salt = customerId;
    const hashingAlgorithm = Crypto.CryptoDigestAlgorithm.SHA256;
    const plaintext = password;
    const salted = plaintext.concat(salt);
    const hash = await Crypto.digestStringAsync(hashingAlgorithm, salted);
    return hash;
  } catch (err) {
    console.error(err);
    logErrorToSentry({
      action: 'encryptPassword',
      error: err,
    });
  }
  return null;
};

// newToken is the value generated by Expo; a string
// updateCustomerPushTokens is called after customer is looked up
export async function updateCustomerPushTokens(customer, newToken) {
  // If tokens are not being registered, do nothing
  if (!newToken) {
    return;
  }
  // If Notifications errored while registering token, may not have registered a pushToken initially
  // Else, we need to check if this device has already been registered to the user
  const isNew =
    'pushTokenIds' in customer &&
    'tokenNames' in customer &&
    !customer.tokenNames.includes(newToken);
  if (isNew) {
    const tokenId = await createPushTokens(newToken);
    await updateCustomers(customer.id, {
      pushTokenIds: [...customer.pushTokenIds, tokenId],
    });
  }
}

export function formatPhoneNumber(phoneNumber) {
  const onlyNumeric = phoneNumber.replace('[^0-9]', '');
  const formatted = `(${onlyNumeric.slice(0, 3)}) ${onlyNumeric.slice(
    3,
    6
  )}-${onlyNumeric.slice(6, 10)}`;
  return formatted;
}
